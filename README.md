## January 26

- [x] 5.1: The dutch national flag problem
- [x] 5.2: Increment an arbitrary-precision integer
- [x] 5.3: Multiply two arbitrary-precision integers
- [x] 5.4: Advancing through an array
- [x] 6.1: Interconvert strings and integers
- [x] 6.2: Base conversion
- [x] 6.3: Compute the spreadsheet column encoding

## January 27

- [ ] 6.4: Replace and remove
- [x] 7.1: Merge two sorted lists
- [x] 7.2: Reverse a single sublist
- [x] 7.3: Test for cyclicity
- [x] 7.4: Test for overlapping lists-lists are cycle-free
- [x] 8.1: Implement a stack with max API
- [x] 8.2: Evaluate RPN expressions

## January 28

- [x] 8.3: Test a string over '{,},(,),[,]' for well-formedness
- [ ] 8.4: Normalize pathnames
- [x] 9.1: Test if a binary tree is height balanced
- [x] 9.2: Test if a binary tree is symmetric
- [x] 9.3: Compute the lowest common ancestor in a binary tree
- [x] 9.4: Compute the LCA when nodes have parent pointers
- [ ] 10.1: Merge sorted files

## January 29

- [ ] 10.2: Sort an increasing-decreasing array
- [ ] 10.3: Sort an almost-sorted array
- [ ] 10.4: Compute the k closest stars
- [ ] 11.1: Search a sorted array for the first occurrence of k
- [ ] 11.2: Search a sorted array for entry equal to its index
- [ ] 11.3: Search a ciclically sorted array
- [ ] 11.4: Compute the integer square root

## January 30

- [ ] 12.1: Test for palindromic permutations
- [ ] 12.2: Is an anonymous letter constructible
- [ ] 12.3: Implement an ISBN cache
- [ ] 12.4: Compute the LCA, optimizing for close ancestors
- [ ] 13.1: Compute the intersection of two sorted arrays
- [ ] 13.2: Merge two sorted arrays
- [ ] 13.3: Remove first-name duplicates

## January 31

- [ ] 13.4: Smallest nonconstructible value
- [x] 14.1: Test if a binary tree satisfies the BST property
- [x] 14.2: Find the first key greater than a given value in a BST
- [ ] 14.3: Find the k largest elements in a BST
- [ ] 14.4: Compute the LCA in a BST
- [ ] 18.1: Search a maze
- [ ] 18.2: Paint a boolean matrix

## February 1

- [ ] 18.3: Compute enclosed regions
- [ ] 18.4: Deadlock detection
- [ ] 5.5: Delete duplicates from a sorted array
- [ ] 5.6: Buy and sell a stock once
- [ ] 5.7: Buy and sell a stock twice
- [ ] 5.8: Computing an alternation
- [ ] 6.5: Test palindromicity

## February 2

- [ ] 6.6: Reverse all the words in a sentence
- [ ] 6.7: Compute all mnemonics for a phone number
- [ ] 6.8: The look-and-say problem
- [ ] 7.5: Test for overlapping lists-lists may have cycles
- [ ] 7.6: Delete a node from a singly linked list
- [ ] 7.7: Remove the kth last element from a list
- [ ] 7.8: Remove duplicates from a sorted list

## February 3

- [ ] 8.5: Search a postings list
- [ ] 8.6: Compute buildings with a sunset view
- [ ] 8.7: Compute binary tree nodes in order of increasing depth
- [ ] 8.8: Implement a circular queue
- [ ] 9.5: Sum the root-to-leaf paths in a binary tree
- [ ] 9.6: Find a root to leaf path with specified sum
- [ ] 9.7: Implement an inorder traversal without recursion

## February 4

- [ ] 9.8: Implement a preorder traversal without recursion
- [ ] 10.5: Compute the median of online data
- [ ] 10.6: Compute the k largest elements in a max-heap
- [ ] 10.7: Implement a stack API using a heap
- [ ] 11.5: Compute the real square root
- [ ] 11.6: Search in a 2D sorted array
- [ ] 11.7: Find the min and max simultaneously

## February 5 Interviewing.io mock interview

- [ ] 11.8:  Find the kth largest element
- [ ] 12.5: Compute the k most frequent queries
- [ ] 12.6: Find the nearest repeared entries in an array
- [ ] 12.7: Find the smallest subarray covering all values
- [ ] 12.8: Find the smallest subarray sequentially covering all values
- [ ] 13.5: Render a calendar
- [ ] 13.6: Merging intervals

## February 6

- [ ] 13.7: Compute the union of intervals
- [ ] 13.8: Partitioning and sorting an array with many repeated entries
- [ ] 14.5: Reconstruct a BST from traversal data
- [ ] 14.6: Find the closest entries in three sorted arrays
- [ ] 14.7: Enumerate numbers in the form a + b SQRT(2)
- [ ] 14.8: The most visited pages problem
- [ ] 18.5: Clone a graph

## February 7

- [ ] 18.6: Making wired connections
- [ ] 18.7: Transform one string to another
- [ ] 18.8: Team photo day-2
- [ ] 5.9: Enumerate all primes to n
- [ ] 5.10: Permute the elements of an array
- [ ] 5.11: Compute the next permutation
- [ ] 5.12: Sample offline data

## February 8

- [ ] 6.9: Convert from Roman to decimal
- [ ] 6.10: Compute all valid IP addresses
- [ ] 6.11: Write a string sinusoidally
- [ ] 6.12: Implement run-length encoding
- [ ] 7.9: Implement cyclic right shoft for singly linked list
- [ ] 7.10: Implement even-odd merge
- [ ] 7.11: Test whether a slingly linked list is palindromic

## February 9

- [ ] 7.12: Implement list pivoting
- [ ] 8.9: Implement a queue using stacks
- [ ] 8.10: Implement a queue with max API
- [ ] 9.9: Compute the kth node in an inorder traversal
- [ ] 9.10: Compute the successor
- [ ] 9.11: Implement an inorder traversal with O(1) space
- [ ] 9.12: Reconstruct a binary tree from traversal data

## February 10

- [ ] 11.9: Find the missing IP address
- [ ] 11.10: Find the duplicate and missing elements
- [ ] 12.9: Find the longest subarray with distinct entries
- [ ] 12.10: Find the length of a longest contained interval
- [ ] 12.11: Find the student with the top three scores
- [ ] 12.12: Compute all string decompositions
- [ ] 13.9: Team photo day-1

## February 11

- [ ] 13.10: Implement a fast sorting algorithm for lists
- [ ] 13.11: Compute a salary threshold
- [ ] 13.12: SORT5
- [ ] 14.9: Build a minimum height BST from a sorted array
- [ ] 14.10: Insertion and deletion in a BST
- [ ] 14.11: Test if three BST nodes are totally ordered
- [ ] 14.12: The range lookup problem

## February 12

- [ ] 18.9: Compute a shortest path with fewest edges
- [ ] 5.13: Sample online data
- [ ] 5.14: Compute a random permutation
- [ ] 5.15: Compute a random subset
- [ ] 5.16: Generate nonuniform random numbers
- [ ] 6.13: Find the first occurrence of a substring
- [ ] 7.13: Add list-based integers

## February 13 FB Interview

- [ ] 9.13: Reconstruct a binary tree from preorder traversal with markers
- [ ] 9.14: Form a linked list from the leaves of a binary tree
- [ ] 9.15: Compute the exterior of a binary tree
- [ ] 9.16: Compute the right sibling tree
- [ ] 12.13: Test the Collatz conkecture
- [ ] 12.14: Implement a hash function for chess
- [ ] 14.13: Add credits

## February 14

- [ ] 5.17: The sudoku checker problem
- [ ] 5.18: Compute the spiral ordering of a 2D array
- [ ] 5.19: Rotate a 2D array
- [ ] 5.20: Compute rows in Pascal's triangle
- [ ] 9.17: Implement locking in a binary tree

## February 15

## February 16

## February 17

## February 18 Google Interview
